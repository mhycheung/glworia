{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/amp/amplification_factor/","title":"API for the <code>glworia.am.amplification_factor</code> module","text":""},{"location":"api/amp/amplification_factor/#glworia.amp.amplification_factor.amplification_computation_prep","title":"<code>amplification_computation_prep(Psi, **kwargs)</code>","text":"<p>Constructs the functions needed for computing the amplification factor.</p> <p>Parameters:</p> Name Type Description Default <code>Psi</code> <code>Callable</code> <p>The Fermat potential of the lens model.</p> required <p>Other Parameters:</p> Name Type Description <code>h</code> <code>float</code> <p>The step size for numerical differentiation.</p> <code>newt_tol</code> <code>float</code> <p>The tolerance for the Newton's method.</p> <code>newt_max_iter</code> <code>int</code> <p>The maximum number of iterations for the Newton's method.</p> <code>bisect_tol</code> <code>float</code> <p>The tolerance for the bisection method.</p> <p>Returns:</p> Name Type Description <code>T_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions needed for computing the amplification factor.</p> <code>helper_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of helper functions needed for computing the amplification factor.</p>"},{"location":"tutorial/PE_tutorial/","title":"Parameter Estimation with Bilby","text":"<p>Given an interpolation table of the lensing amplification factor and an unlensed waveform model, the lensed waveform can be rapidly called.</p> <p>While any value on the \\(y\\)-\\(l\\) plane (where \\(y\\) is the impact parameter and \\(l\\) the lens parameter) can be interpolated in principle as long as the value lies within the boundaries of the interpolation table, the interpolated amplification is ill-behaved close to the caustic because the magnification diverges formally. Therefore, when sampling over the \\(y\\)-\\(l\\) plane for parameter estimation, we will ignore the region close to the caustic by assigning it a zero prior probability as implemented in the <code>glworia.pe.prior</code> module. We define such a region as the region between \\(y_c(l) \\pm \\delta\\), where \\(y_c(l)\\) is the caustic curve in the \\(y\\)-\\(l\\) plane, and \\(\\delta\\) is a constant.  For lens models that will reduce to the SIS lens at certain limits (e.g. \\(x_c \\to 0\\) for the CIS lens, or \\(k \\to 1\\) for gSIS), we also exclude the region close to the \\(y = 1\\) caustic at those limits by setting the prior probability within a small rectangle to be zero.</p> <p>Example parameter estimation scripts using <code>bilby</code> can be found in the <code>bilby_scripts/</code> directory in the Git repo. The scripts can be run with a configuration file.</p> <pre><code>PE_full.py /path/to/config_file.json\n</code></pre> <p>Example configuration files can be found in the <code>config/</code> directory. The dictionaries required in the <code>json</code> configuration file are as follows:</p> <ul> <li><code>injection_parameters</code>: the injected parameters for the lensed waveform. These include all the parameters of the unlensed waveform (passed to the waveform generator in <code>bilby</code>), in addition to the following lens parameters:     | Name | Type | Description |     | ----------- | ----------- | ----------- |     | <code>y</code> | <code>float</code> | Injected impact parameter for the lensing set-up |     | <code>MLz</code> | <code>float</code> | Injected redshifted lens mass |      | <code>lp</code> | <code>float</code> | Injected lens parameter of the lens |</li> <li><code>waveform_arguments</code>: the keyword arguments to be passed to the waveform generator in <code>bilby</code></li> <li><code>sampler_settings</code>: the keyword arguments to be passed to the <code>bilby</code> sampler object.</li> <li><code>interpolator_settings</code>: the settings of the interpolator used, see the tutorial for loading the interpolation tables for more details.</li> <li><code>prior_settings</code>: the settings for the priors of the lensing related parameters and <code>luminosity_distance</code>. For example, the prior type (<code>uniform</code>, <code>loguniform</code>) and limits of <code>MLz</code> can be specified by <code>MLz_prior_type</code>, <code>MLz_min</code> and <code>MLz_max</code>. For <code>luminosity_distance</code>, the prior can be chosen to be <code>uniformsourceframe</code>. Additional arguements for masking the region near the caustic are as follows:     | Name | Type | Description |     | ----------- | ----------- | ----------- |     | <code>crit_mask_settings</code> | <code>dict</code>| Parameters of the masker around the caustic, including <code>fac</code>, <code>cap_high</code> and <code>cap_low</code>. The masked region is defined to be between <code>y_c - min( y_c * fac, y_c - cap_low )</code> and <code>y_c + min( y_c * fac, y_c + cap_high)</code>. |     | <code>mask_boxes</code> | <code>list</code> | Each item is a list <code>[[y_low, y_high],[l_low, l_high]]</code>, the boundaries of a rectangular region to exclude in the \\(y\\)-\\(l\\) plane |</li> <li><code>misc</code>: miscellaneous settings as follows:     | Name | Type | Description |     | ----------- | ----------- | ----------- |     | <code>zero_noise</code> | <code>bool</code> | Whether to perform a zero-noise injection. |     | <code>sampling_frequency</code> | <code>float</code> | The sampling rate of the signal in Hertz. |     | <code>minimum_frequency</code> | <code>float</code> | Minimum frequency cut-off. |     | <code>seed</code> | <code>int</code> | The seed used to generate random numbers for sampling. |     | <code>lp_name</code> | <code>str</code> | The name given to the lens parameter, e.g. <code>kappa</code> for the NFW lens. |     | <code>lp_latex</code> | <code>str</code> | The name of the lens parameter in latex form for making plots |     | <code>outdir_ext</code> | <code>str</code> | The name of the output directory |</li> </ul>"},{"location":"tutorial/example_amplification_minimal/","title":"Computing the amplification factor","text":"In\u00a0[1]: Copied! <pre>from jax import jit\nimport jax.numpy as jnp\n\nfrom glworia.amp.lens_model import LensModel\nfrom glworia.amp.amplification_factor import (amplification_computation_prep, \n                                          crtical_curve_interpolants,\n                                          compute_F)\nfrom glworia.amp.root import make_crit_curve_helper_func\nimport matplotlib.pyplot as plt\n</pre> from jax import jit import jax.numpy as jnp  from glworia.amp.lens_model import LensModel from glworia.amp.amplification_factor import (amplification_computation_prep,                                            crtical_curve_interpolants,                                           compute_F) from glworia.amp.root import make_crit_curve_helper_func import matplotlib.pyplot as plt <pre>WARNING: All log messages before absl::InitializeLog() is called are written to STDERR\nI0000 00:00:1706818445.491190  827101 tfrt_cpu_pjrt_client.cc:349] TfrtCpuClient created.\nNo GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[2]: Copied! <pre>class PlummerLens(LensModel):\n\n    def __init__(self):\n        pass\n\n    def get_Psi(self):\n        @jit\n        def Psi_Plummer(x, lens_params):\n            kappa = lens_params[0]\n            return kappa / 2 * jnp.log(1 + jnp.linalg.norm(x)**2)\n        return Psi_Plummer\n</pre> class PlummerLens(LensModel):      def __init__(self):         pass      def get_Psi(self):         @jit         def Psi_Plummer(x, lens_params):             kappa = lens_params[0]             return kappa / 2 * jnp.log(1 + jnp.linalg.norm(x)**2)         return Psi_Plummer In\u00a0[3]: Copied! <pre>lm = PlummerLens()\nPsi_Plummer = lm.get_Psi()\nT_funcs, helper_funcs = amplification_computation_prep(Psi_Plummer)\ncrit_curve_helper_funcs = make_crit_curve_helper_func(T_funcs)\n</pre> lm = PlummerLens() Psi_Plummer = lm.get_Psi() T_funcs, helper_funcs = amplification_computation_prep(Psi_Plummer) crit_curve_helper_funcs = make_crit_curve_helper_func(T_funcs) In\u00a0[4]: Copied! <pre>param_arr = jnp.linspace(0.1, 10., 100000)\ncrit_funcs = crtical_curve_interpolants(param_arr, T_funcs, crit_curve_helper_funcs)\n</pre> param_arr = jnp.linspace(0.1, 10., 100000) crit_funcs = crtical_curve_interpolants(param_arr, T_funcs, crit_curve_helper_funcs) In\u00a0[5]: Copied! <pre>ws = jnp.linspace(1e-2, 1e3, 10**6)\ny = jnp.array([0.1, 0.])\nlens_params = jnp.array([5.])\n\nN = 200\nT0_max = 1000.\n\nF_interp, _, _, _ = compute_F(ws, y, lens_params, T_funcs, helper_funcs, crit_funcs,\n              N, T0_max)\n</pre> ws = jnp.linspace(1e-2, 1e3, 10**6) y = jnp.array([0.1, 0.]) lens_params = jnp.array([5.])  N = 200 T0_max = 1000.  F_interp, _, _, _ = compute_F(ws, y, lens_params, T_funcs, helper_funcs, crit_funcs,               N, T0_max) In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots()\nax.semilogx(ws, jnp.abs(F_interp))\nax.set_xlabel(r'$w$')\nax.set_ylabel(r'$|F|$')\n</pre> fig, ax = plt.subplots() ax.semilogx(ws, jnp.abs(F_interp)) ax.set_xlabel(r'$w$') ax.set_ylabel(r'$|F|$') Out[6]: <pre>Text(0, 0.5, '$|F|$')</pre>"},{"location":"tutorial/example_load_interpolation/","title":"Loading an interpolation table","text":"In\u00a0[19]: Copied! <pre>from glworia.amp.load_interp import load_interpolators, F_interp\nimport json\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from glworia.amp.load_interp import load_interpolators, F_interp import json import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>interpolation_dir_path = '../../interpolation'\n</pre> interpolation_dir_path = '../../interpolation' In\u00a0[3]: Copied! <pre>settings_file_path = '../../settings/NFW_prod1.json'\n</pre> settings_file_path = '../../settings/NFW_prod1.json' In\u00a0[4]: Copied! <pre>with open(settings_file_path, 'r') as f:\n    settings = json.load(f)\n</pre> with open(settings_file_path, 'r') as f:     settings = json.load(f) In\u00a0[6]: Copied! <pre>interpolators = load_interpolators(interpolation_dir_path, **settings)\n</pre> interpolators = load_interpolators(interpolation_dir_path, **settings) In\u00a0[30]: Copied! <pre>w_interp = np.linspace(0.001, 1e4, 10**6)\ny_interp = 0.23456\nlp_interp = 5.01234\n</pre> w_interp = np.linspace(0.001, 1e4, 10**6) y_interp = 0.23456 lp_interp = 5.01234 In\u00a0[31]: Copied! <pre>F = F_interp(w_interp, y_interp, lp_interp, interpolators, settings)\n</pre> F = F_interp(w_interp, y_interp, lp_interp, interpolators, settings) In\u00a0[33]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize = (12, 5))\naxs[0].semilogx(w_interp, np.abs(F))\naxs[1].semilogx(w_interp, np.angle(F))\n\naxs[0].set_xlabel('$w$')\naxs[0].set_ylabel('$|F|$')\naxs[1].set_xlabel('$w$')\naxs[1].set_ylabel(r'$\\arg(F)$')\n</pre> fig, axs = plt.subplots(1, 2, figsize = (12, 5)) axs[0].semilogx(w_interp, np.abs(F)) axs[1].semilogx(w_interp, np.angle(F))  axs[0].set_xlabel('$w$') axs[0].set_ylabel('$|F|$') axs[1].set_xlabel('$w$') axs[1].set_ylabel(r'$\\arg(F)$') Out[33]: <pre>Text(0, 0.5, '$\\\\arg(F)$')</pre>"},{"location":"tutorial/example_load_interpolation/#constructing-an-interpolation-table","title":"Constructing an interpolation table\u00b6","text":"<p>To construct an interpolation table, use the <code>do_interpolation.py</code> python script with a configuration file.</p> <pre><code>python scripts/do_interpolation.py -f /path/to/config_file.json -s /path/to/output/directory -im\n</code></pre> Option flag Description <code>--input-file</code> <code>-f</code> Path to configuration file. <code>--save-dir</code> <code>-s</code> Path to directory for saving the interpolation tables. <code>--image</code> <code>-im</code> Also construct an interpolation table for the image magnifications and time delays, in addition to the amplification factor. <code>--skip-strong</code> <code>-ss</code> Skip the strong lensing region in the parameter space. <code>--skip-weak</code> <code>-sw</code> Skip the weak lensing region in the parameter space. <code>--skip-amplification</code> <code>-sa</code> Skip the computation of the amplification factor. <p>The configuration file should be in <code>json</code> format with the following entries:</p> Parameter Type Description <code>lens_param_name</code> <code>str</code> Name given to the lens parameter $l$, e.g. <code>kappa</code> for the NFW lens or <code>x_c</code> for the CIS lens. <code>y_low</code> <code>float</code> Lower limit of the impact parameter $y$ in the interpolation domain. <code>y_high</code> <code>float</code> Upper limit of the impact parameter $y$ in the interpolation domain. <code>lp_low</code> <code>float</code> Lower limit of the lens parameter $l$ in the interpolation domain. <code>lp_high</code> <code>float</code> Upper limit of the lens parameter $l$ in the interpolation domain. <code>N_grid</code> <code>int</code> Number of interpolation nodes to use in each dimension on the $y$-$l$ plane to use for the weak lensing region. <code>N_grid_strong</code> <code>int</code> Number of interpolation nodes to use in each dimension on the $y$-$l$ plane to use for the strong lensing region. <code>N_crit</code> <code>int</code> Number of interpolation nodes on the caustic curve. <code>N</code> <code>int</code> Number of interpolation nodes in dimensionless time $\\tau$ to use in each section of the time domain amplification factor. <code>lens_model_name</code> <code>str</code> The name of the lens model, e.g. <code>NFW</code>. <code>crit_lp_N</code> <code>int</code> Number of points in $l$ to use for a high-resolution interpolator tracing out the caustic curve in the $y$-$l$ plane. <code>im_x_init_low</code> <code>float</code> Lower limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_high</code> <code>float</code> Upper limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_num</code> <code>int</code> Number of points in the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>lp_low_im</code> <code>float</code> Lower limit of the lens parameter $l$ in the interpolation domain for image related quantities. <code>lp_high_im</code> <code>float</code> Upper limit of the lens parameter $l$ in the interpolation domain for image related quantities. <code>N_grid_im</code> <code>int</code> Number of interpolation nodes to use in each dimension on the $y$-$l$ plane to use for interpolating image related quantities. <code>N_crit_im</code> <code>int</code> Number of interpolation nodes to use on the caustic curve for interpolating image related quantities. <code>newt_max_iter_im</code> <code>int</code> Maximum iterations for Newton's method when solving for the image positions. <code>crit_lp_im</code> <code>int</code> Number of points in $l$ to use for a high-resolution interpolator tracing out the caustic curve in the $y$-$l$ plane, for calculations related to the images."},{"location":"tutorial/interpolation_tutorial/","title":"Constructing an interpolation table","text":"<p>To construct an interpolation table, use the <code>do_interpolation.py</code> python script with a configuration file.</p> <pre><code>python scripts/do_interpolation.py -f /path/to/config_file.json -s /path/to/output/directory -im\n</code></pre> Option flag Description <code>--input-file</code> <code>-f</code> Path to configuration file. <code>--save-dir</code> <code>-s</code> Path to directory for saving the interpolation tables. <code>--image</code> <code>-im</code> Also construct an interpolation table for the image magnifications and time delays, in addition to the amplification factor. <code>--skip-strong</code> <code>-ss</code> Skip the strong lensing region in the parameter space. <code>--skip-weak</code> <code>-sw</code> Skip the weak lensing region in the parameter space. <code>--skip-amplification</code> <code>-sa</code> Skip the computation of the amplification factor. <p>The configuration file should be in <code>json</code> format with the following entries:</p> Parameter Type Description <code>lens_param_name</code> <code>str</code> Name given to the lens parameter \\(l\\), e.g. <code>kappa</code> for the NFW lens or <code>x_c</code> for the CIS lens. <code>y_low</code> <code>float</code> Lower limit of the impact parameter \\(y\\) in the interpolation domain. <code>y_high</code> <code>float</code> Upper limit of the impact parameter \\(y\\) in the interpolation domain. <code>lp_low</code> <code>float</code> Lower limit of the lens parameter \\(l\\) in the interpolation domain. <code>lp_high</code> <code>float</code> Upper limit of the lens parameter \\(l\\) in the interpolation domain. <code>N_grid</code> <code>int</code> Number of interpolation nodes to use in each dimension on the \\(y\\)-\\(l\\) plane to use for the weak lensing region. <code>N_grid_strong</code> <code>int</code> Number of interpolation nodes to use in each dimension on the \\(y\\)-\\(l\\) plane to use for the strong lensing region. <code>N_crit</code> <code>int</code> Number of interpolation nodes on the caustic curve. <code>N</code> <code>int</code> Number of interpolation nodes in dimensionless time \\(\\tau\\) to use in each section of the time domain amplification factor. <code>lens_model_name</code> <code>str</code> The name of the lens model, e.g. <code>NFW</code>. <code>crit_lp_N</code> <code>int</code> Number of points in \\(l\\) to use for a high-resolution interpolator tracing out the caustic curve in the \\(y\\)-\\(l\\) plane. <code>im_x_init_low</code> <code>float</code> Lower limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_high</code> <code>float</code> Upper limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_num</code> <code>int</code> Number of points in the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>lp_low_im</code> <code>float</code> Lower limit of the lens parameter \\(l\\) in the interpolation domain for image related quantities. <code>lp_high_im</code> <code>float</code> Upper limit of the lens parameter \\(l\\) in the interpolation domain for image related quantities. <code>N_grid_im</code> <code>int</code> Number of interpolation nodes to use in each dimension on the \\(y\\)-\\(l\\) plane to use for interpolating image related quantities. <code>N_crit_im</code> <code>int</code> Number of interpolation nodes to use on the caustic curve for interpolating image related quantities. <code>newt_max_iter_im</code> <code>int</code> Maximum iterations for Newton's method when solving for the image positions. <code>crit_lp_im</code> <code>int</code> Number of points in \\(l\\) to use for a high-resolution interpolator tracing out the caustic curve in the \\(y\\)-\\(l\\) plane, for calculations related to the images."}]}