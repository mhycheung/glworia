{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"glworia   A python package for gravitational-wave lensing computations including wave-optics effects."},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Compute the frequency-dependent lensing amplification factor</li> <li>Use your custom lens model, any spherically symmetry lens is supported</li> <li>The only function you need to provide is the Fermat potential - <code>jax</code> will take care of the rest with auto differentiation!</li> <li>Build interpolation tables for your lens model</li> <li>Perform Bayesian parameter estimation with <code>bilby</code></li> <li>Runs on GPUs</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install glworia\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Basic usage examples can be found under the Examples tab on the left.</p>"},{"location":"#how-to-cite","title":"How to Cite","text":"<p>Please cite the methods paper if you used our package to produce results in your publication. Here is the BibTeX entry:</p> <pre><code>Coming soon!\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT</p> <p>GitHub @mhycheung</p>"},{"location":"api/amp/amplification_factor/","title":"API for the <code>glworia.amp.amplification_factor</code> module","text":""},{"location":"api/amp/amplification_factor/#glworia.amp.amplification_factor.amplification_computation_for_interpolation","title":"<code>amplification_computation_for_interpolation(T_funcs, helper_funcs, crit_funcs, y, lens_params, **kwargs)</code>","text":"<p>Compute the contour integral for constructing interpolation tables of the time domain amplification factor.</p> <p>Parameters:</p> Name Type Description Default <code>T_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions derived from the Fermat potential needed for computing the amplification factor.</p> required <code>helper_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of helper functions needed for the numerical implementation.</p> required <code>crit_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions for computing the caustic curve.</p> required <code>y</code> <code>ndarray</code> <p>The 2D impact parameter. For now the second component is not used.</p> required <code>lens_params</code> <code>ndarray</code> <p>The lens model parameter. For now only one parameter is supported.</p> required <p>Other Parameters:</p> Name Type Description <code>im_x_init_low</code> <code>float</code> <p>The lower bound for the initial guess of the image position.</p> <code>im_x_init_high</code> <code>float</code> <p>The upper bound for the initial guess of the image position.</p> <code>im_x_init_num</code> <code>int</code> <p>The number of initial guesses of the image position.</p> <code>im_screen_round_decimal</code> <code>int</code> <p>The number of decimal places to round the image position.</p> <code>T0_max</code> <code>float</code> <p>The maximum value of the time delay to compute the time domain amplification up to.</p> <code>crit_run</code> <code>bool</code> <p>Whether the run corresponds to a run on the caustic.</p> <code>N</code> <code>int</code> <p>The number of interpolation node in time in each segment.</p> <code>return_all</code> <code>bool</code> <p>Whether to return all the computed values for debugging.</p> <code>singular</code> <code>bool</code> <p>Whether the center of the lens is singular, i.e. a cusp or a pole in the time delay function.</p> <code>origin_type</code> <code>Callable</code> <p>A function that returns the origin type of the lens model (cusp, pole or regular).</p> <code>y_crit_override</code> <code>Callable</code> <p>A function that overrides the computed values of the caustic curve.</p> <code>x_im_nan_sub</code> <code>Callable</code> <p>A function that substitutes <code>nan</code> values for the image position.</p> <code>add_to_strong</code> <code>Callable</code> <p>A function decides whether to add certain points to the strong lensing regime.</p> <code>T_vir_low_bound</code> <code>float</code> <p>The lower bound in time delay when searching for the maximum point of the time domain amplification.</p> <p>Returns:</p> Name Type Description <code>contour_int</code> <code>contour_integral</code> <p>The contour integral object.</p> <code>T0_min_out_segs</code> <code>list[ndarray]</code> <p>The corresponding time delays of the interpolation nodes for contour lines around the minimum. Each element of the list corresponds to a segment.</p> <code>T0_arr_sad_max</code> <code>ndarray</code> <p>The corresponding time delays of the interpolation nodes for contour lines around the maximum point.</p> <code>x_im</code> <code>ndarray</code> <p>The image positions.</p> <code>T_val_max</code> <code>float</code> <p>The time delay at the maximum value of the time domain amplification.</p>"},{"location":"api/amp/amplification_factor/#glworia.amp.amplification_factor.amplification_computation_prep","title":"<code>amplification_computation_prep(Psi, **kwargs)</code>","text":"<p>Constructs the functions needed for computing the amplification factor.</p> <p>Parameters:</p> Name Type Description Default <code>Psi</code> <code>Callable</code> <p>The Fermat potential of the lens model.</p> required <p>Other Parameters:</p> Name Type Description <code>h</code> <code>float</code> <p>The step size for numerical differentiation.</p> <code>newt_tol</code> <code>float</code> <p>The tolerance for the Newton's method.</p> <code>newt_max_iter</code> <code>int</code> <p>The maximum number of iterations for the Newton's method.</p> <code>bisect_tol</code> <code>float</code> <p>The tolerance for the bisection method.</p> <p>Returns:</p> Name Type Description <code>T_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions needed for computing the amplification factor.</p> <code>helper_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of helper functions needed for computing the amplification factor.</p>"},{"location":"api/amp/amplification_factor/#glworia.amp.amplification_factor.chev_first_half","title":"<code>chev_first_half(a, b, n)</code>","text":"<p>Returns the first n points out of 2*n Chebyshev points, with the n points covering the interval [a, b].</p>"},{"location":"api/amp/amplification_factor/#glworia.amp.amplification_factor.chev_points","title":"<code>chev_points(a, b, n)</code>","text":"<p>Returns n Chebyshev points in the interval [a, b].</p>"},{"location":"api/amp/amplification_factor/#glworia.amp.amplification_factor.compute_F","title":"<code>compute_F(w_interp, y, lens_params, T_funcs, helper_funcs, crit_funcs, N, T0_max, crit_run=False, singular=False, origin='regular', **kwargs)</code>","text":"<p>Compute the amplification factor in the frequency domain.</p> <p>Parameters:</p> Name Type Description Default <code>w_interp</code> <code>ndarray</code> <p>The frequencies to compute the amplification factor.</p> required <code>y</code> <code>ndarray</code> <p>The 2D impact parameter. For now the second component is not used.</p> required <code>lens_params</code> <code>ndarray</code> <p>The lens model parameter. For now only one parameter is supported.</p> required <code>T_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions derived from the Fermat potential needed for computing the amplification factor.</p> required <code>helper_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of helper functions needed for the numerical implementation.</p> required <code>crit_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions for computing the caustic curve.</p> required <code>N</code> <code>int</code> <p>The number of interpolation node in time in each segment.</p> required <code>T0_max</code> <code>float</code> <p>The maximum value of the time delay to compute the time domain amplification up to.</p> required <code>crit_run</code> <code>bool</code> <p>Whether the run corresponds to a run on the caustic.</p> <code>False</code> <code>singular</code> <code>bool</code> <p>Whether the center of the lens is singular, i.e. a cusp or a pole in the time delay function.</p> <code>False</code> <code>origin</code> <code>str</code> <p>The origin type of the lens model (cusp, pole or regular).</p> <code>'regular'</code> <p>Other Parameters:</p> Name Type Description <code>N_fft</code> <code>int</code> <p>The number of points in the Fast Fourier Transform.</p> <code>t_fft_short_max_fac</code> <code>float</code> <p>The factor determining the maximum value of the time delay to compute the amplification factor in the short time regime.</p> <code>t_fft_long_max_fac</code> <code>float</code> <p>The factor determining the maximum value of the time delay to compute the amplification factor in the long time regime.</p> <code>w_trans_weak_fac</code> <code>List[float]</code> <p>The transition frequencies between different FFT regimes and geometrical optics for the weak lensing regime.</p> <code>w_trans_strong_fac</code> <code>List[float]</code> <p>The transition frequencies between different FFT regimes and geometrical optics for the strong lensing regime.</p> <code>sig_fac</code> <code>float</code> <p>The width of the transition region.</p> <code>**kwargs</code> <p>Additional keyword arguments passed to <code>amplification_computation_for_interpolation</code>.</p> <p>Returns:</p> Name Type Description <code>F_interp</code> <code>ndarray</code> <p>The interpolated amplification factor.</p> <code>F_interp_raw</code> <code>List[ndarray]</code> <p>A list of the amplification factor from the different FFT regimes, for debugging.</p> <code>contour_obj</code> <code>contour_integral</code> <p>The contour integral object.</p> <code>partitions</code> <code>ndarray</code> <p>The transition frequencies.</p>"},{"location":"api/amp/contour/","title":"API for the <code>glworia.amp.contour</code> module","text":""},{"location":"api/amp/contour/#glworia.amp.contour.contour_integral","title":"<code>contour_integral</code>","text":"<p>A class for computing the amplification factor by contour integration.</p> <p>Attributes:</p> Name Type Description <code>y</code> <code>ndarray</code> <p>2D impact parameter. The second component is ignored for now.</p> <code>y0</code> <code>float</code> <p>1D impact parameter.</p> <code>lens_params</code> <code>ndarray</code> <p>The lens parameters. Only one parameter is supported for now.</p> <code>T0_min_out_segments</code> <code>List[ndarray]</code> <p>A list of the arrays of time delay values for the contours passing to the right of the minimum image.</p> <code>T0_sad_max_segment</code> <code>ndarray</code> <p>The time delay values for the contours passing between the saddle and the maximum image.</p> <code>x_im</code> <code>ndarray</code> <p>The image positions in 1D. The order of the images are from the left to the right, i.e. saddle, maximum, minimum.</p> <code>mus</code> <code>ndarray</code> <p>The magnification of the images.</p> <code>u_min_out</code> <code>List[ndarray]</code> <p>A list of arrays of the time domain amplification for the contours passing to the right of the minimum image, corresponding to the time delays <code>T0_min_out_segments</code>.</p> <code>u_sad_max</code> <code>ndarray</code> <p>The time domain amplification for the contours passing between the saddle and the maximum image, corresponding to the time delays <code>T0_sad_max_segment</code>.</p> <code>T_vir</code> <code>float</code> <p>The time delay at the maximum value of the time domain amplification.</p>"},{"location":"api/amp/contour/#glworia.amp.contour.contour_integral.__init__","title":"<code>__init__(x_im, multi_image, T_funcs, y, lens_params, critical=False, T0_min_out_segments=None, T0_sad_max_segment=None, singular=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>x_im</code> <code>ndarray</code> <p>The image positions in 1D. The order of the images are from the left to the right, i.e. saddle, maximum, minimum.</p> required <code>multi_image</code> <code>bool</code> <p>A boolean indicating whether there are multiple images.</p> required <code>T_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions derived from the Fermat Potential.</p> required <code>y</code> <code>ndarray</code> <p>2D impact parameter. The second component is ignored for now.</p> required <code>lens_params</code> <code>ndarray</code> <p>The lens parameters. Only one parameter is supported for now.</p> required <code>critical</code> <code>bool</code> <p>A boolean indicating whether the supplied impact parameter lies on the caustic.</p> <code>False</code> <code>T0_min_out_segments</code> <code>Optional[List[ndarray]]</code> <p>A list of the arrays of time delay values for the contours passing to the right of the minimum image.</p> <code>None</code> <code>T0_sad_max_segment</code> <code>Optional[ndarray]</code> <p>The time delay values for the contours passing between the saddle and the maximum image.</p> <code>None</code> <code>singular</code> <code>bool</code> <p>A boolean indicating whether the lens is singular at the origion.</p> <code>False</code>"},{"location":"api/amp/contour/#glworia.amp.contour.contour_integral.contour_integrate","title":"<code>contour_integrate(contour_cond_fun, contour_step_fun)</code>","text":"<p>Computes the contour integral</p> <p>Parameters:</p> Name Type Description Default <code>contour_cond_fun</code> <code>Callable</code> <p>The condition function for terminating the contour integral.</p> required <code>contour_step_fun</code> <code>Callable</code> <p>The step function for the contour integral.</p> required"},{"location":"api/amp/frequency_domain/","title":"API for the <code>glworia.amp.frequency_domain</code> module","text":""},{"location":"api/amp/frequency_domain/#glworia.amp.frequency_domain.interp_partitions_jnp","title":"<code>interp_partitions_jnp(w_interp, ws, Fs, partitions, sigs, T_im, mu_im, origin='regular')</code>","text":"<p>Patches together the interpolated frequency domain amplitude from different frequency regimes.</p> <p>Parameters:</p> Name Type Description Default <code>w_interp</code> <code>ndarray</code> <p>The output frequency array that the interpolated amplitude will be evaluated at.</p> required <code>ws</code> <code>List[ndarray]</code> <p>A list of frequency arrays that the amplitude is interpolated from.</p> required <code>Fs</code> <code>List[ndarray]</code> <p>A list of amplitude arrays that the amplitude is interpolated from.</p> required <code>partitions</code> <code>ndarray</code> <p>The transition frequencies between different frequency regimes. Should have a length one less than <code>ws</code> and <code>Fs</code>.</p> required <code>sigs</code> <code>ndarray</code> <p>The width of the transition regions.</p> required <code>T_im</code> <code>ndarray</code> <p>The time delay of the images.</p> required <code>mu_im</code> <code>ndarray</code> <p>The magnification of the images.</p> required <code>origin</code> <code>str</code> <p>The type of the origin. Can be <code>regular</code>, <code>cusp</code> or <code>im</code>.</p> <code>'regular'</code> <p>Returns:</p> Name Type Description <code>F_interp</code> <code>ndarray</code> <p>The interpolated amplitude.</p> <code>F_interp_raw</code> <code>List[ndarray]</code> <p>A list of the interpolated amplitudes from different frequency regimes.</p>"},{"location":"api/amp/interpolate/","title":"API for the <code>glworia.amp.interpolate</code> module","text":""},{"location":"api/amp/interpolate/#glworia.amp.interpolate.interpolate","title":"<code>interpolate(settings, save_dir=None, strong=True, weak=True, interp_crit=True)</code>","text":"<p>Interpolate the time domain amplification factor and save the interpolation tables.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Dict[str, Union[str, int, float]]</code> <p>a dictionary containing the settings for the interpolation.</p> required <code>save_dir</code> <code>Optional[str]</code> <p>the directory to save the interpolation tables.</p> <code>None</code> <code>strong</code> <code>bool</code> <p>whether to compute and interpolate the strong-lensing points.</p> <code>True</code> <code>weak</code> <code>bool</code> <p>whether to compute and interpolate the weak-lensing points.</p> <code>True</code> <code>interp_crit</code> <code>bool</code> <p>whether to interpolate the caustic curve.</p> <code>True</code>"},{"location":"api/amp/interpolate/#glworia.amp.interpolate.interpolate_im","title":"<code>interpolate_im(settings, save_dir=None)</code>","text":"<p>Interpolate the time delay and magnification of images.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Dict[str, Union[str, float, int]]</code> <p>a dictionary containing the settings for the interpolation.</p> required <code>save_dir</code> <code>Optional[str]</code> <p>the directory to save the interpolation tables.</p> <code>None</code>"},{"location":"api/amp/interpolate/#glworia.amp.interpolate.make_grid_points","title":"<code>make_grid_points(settings, functions_dict=None, mid_point=False)</code>","text":"<p>Make the interpolation node grid points of the amplification factor.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Dict[str, Union[str, float, int]]</code> <p>a dictionary containing the settings for the interpolation.</p> required <code>functions_dict</code> <code>Optional[Dict[str, Dict[str, Callable]]]</code> <p>a dictionary of dictionaries containing relevant functions for computing the amplification factor.</p> <code>None</code> <code>mid_point</code> <code>bool</code> <p>whether to use the mid-points of the grid instead of the grid points themselves. Useful for estimating the error of the interpolation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>weak_points</code> <code>ndarray</code> <p>the interpolation nodes in the weak-lensing regime.</p> <code>strong_points</code> <code>ndarray</code> <p>the interpolation nodes in the strong-lensing regime.</p> <code>crit_points_in_bound</code> <code>ndarray</code> <p>the interpolation nodes on the caustic curve.</p> <code>crit_T_vir</code> <code>ndarray</code> <p>the time delay of the saddle/maximum image on the caustic curve. The saddle and maximum images merge on the caustic.</p> <code>lens_param_to_y_crit</code> <code>Callable</code> <p>a function that maps the lens parameter to y on the caustic curve.</p>"},{"location":"api/amp/lens_functions/","title":"API for the <code>glworia.amp.lens_functions</code> module","text":""},{"location":"api/amp/lens_functions/#glworia.amp.lens_functions.make_T_funcs","title":"<code>make_T_funcs(Psi)</code>","text":"<p>Construct the relevant functions derived from the Fermat Potential.</p> <p>Parameters:</p> Name Type Description Default <code>Psi</code> <code>Callable</code> <p>the Fermat Potential function.</p> required <p>Returns:</p> Name Type Description <code>T_funcs</code> <code>Dict[str, Callable]</code> <p>a dictionary of the relevant functions.</p>"},{"location":"api/amp/lens_model/","title":"API for the <code>glworia.amp.lens_model</code> module","text":""},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel","title":"<code>LensModel</code>","text":"<p>A parent class for lens models. Class methods, most importantly the Fermat Potential function <code>Psi</code>, to be implemented in the child classes.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel.get_Psi","title":"<code>get_Psi()</code>","text":"<p>Returns the Fermat potential function for the lens model. To be implemented in the child classes.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel.get_add_to_strong","title":"<code>get_add_to_strong()</code>","text":"<p>Returns a function for determining whether to add a point to the strong lensing region.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel.get_irregular_crit_points_dict","title":"<code>get_irregular_crit_points_dict()</code>","text":"<p>Returns a dictionary of special caustic points added by hand.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel.get_origin_type","title":"<code>get_origin_type()</code>","text":"<p>Returns a function for obtaining the behavior of the origin of the lens model. Can be 'regular', 'cusp' or 'im'.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel.get_override_funcs_dict","title":"<code>get_override_funcs_dict(dT_1D)</code>","text":"<p>Returns a dictionary of the functions for overriding various results.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel.get_x_im_nan_sub","title":"<code>get_x_im_nan_sub(dT_1D)</code>","text":"<p>Returns a function for overriding the image positions if they are <code>nan</code>.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.LensModel.get_y_crit_override","title":"<code>get_y_crit_override()</code>","text":"<p>Returns a function for overriding the caustic curve computed.</p>"},{"location":"api/amp/lens_model/#glworia.amp.lens_model.get_lens_model","title":"<code>get_lens_model(lens_model_name)</code>","text":"<p>Obtain the <code>LensModel</code> object from the name of the lens model.</p>"},{"location":"api/amp/load_interp/","title":"API for the <code>glworia.amp.load_interp</code> module","text":""},{"location":"api/amp/load_interp/#glworia.amp.load_interp.F_interp","title":"<code>F_interp(w_interp, y_interp, lp_interp, interpolators, settings, return_geom=False, strong_lens_cond_override=strong_lens_cond_override_default)</code>","text":"<p>Interpolate the frequency domain amplification factor for a given frequency array, given interpolation tables.</p> <p>Parameters:</p> Name Type Description Default <code>w_interp</code> <code>ndarray</code> <p>The output frequency array that the interpolated amplitude will be evaluated at.</p> required <code>y_interp</code> <code>float</code> <p>The impact parameter</p> required <code>lp_interp</code> <code>float</code> <p>The value of the lens parameter.</p> required <code>interpolators</code> <code>Dict[str, Any]</code> <p>A dictionary of interpolation tables.</p> required <code>settings</code> <code>Dict[str, Union[str, float, int]]</code> <p>A dictionary of settings including <code>N</code> and <code>T0_max</code>.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the geometrical optics approximated amplification and other quantities for debugging.</p> <code>False</code> <code>strong_lens_cond_override</code> <code>Callable</code> <p>A function that overrides the condition for strong lensing.</p> <code>strong_lens_cond_override_default</code> <p>Returns:</p> Name Type Description <code>F_interp</code> <code>Union[ndarray, Tuple]</code> <p>The interpolated amplitude.</p>"},{"location":"api/amp/load_interp/#glworia.amp.load_interp.load_interpolators","title":"<code>load_interpolators(interpolation_root_dir, **kwargs)</code>","text":"<p>Load the interpolation tables for the amplitude calculation.</p>"},{"location":"tutorial/PE_tutorial/","title":"Parameter Estimation with Bilby","text":"<p>Given an interpolation table of the lensing amplification factor and an unlensed waveform model, the lensed waveform can be rapidly called.</p> <p>While any value on the \\(y\\)-\\(l\\) plane (where \\(y\\) is the impact parameter and \\(l\\) the lens parameter) can be interpolated in principle as long as the value lies within the boundaries of the interpolation table, the interpolated amplification is ill-behaved close to the caustic because the magnification diverges formally. Therefore, when sampling over the \\(y\\)-\\(l\\) plane for parameter estimation, we will ignore the region close to the caustic by assigning it a zero prior probability as implemented in the <code>glworia.pe.prior</code> module. We define such a region as the region between \\(y_c(l) \\pm \\delta\\), where \\(y_c(l)\\) is the caustic curve in the \\(y\\)-\\(l\\) plane, and \\(\\delta\\) is a constant.  For lens models that will reduce to the SIS lens at certain limits (e.g. \\(x_c \\to 0\\) for the CIS lens, or \\(k \\to 1\\) for gSIS), we also exclude the region close to the \\(y = 1\\) caustic at those limits by setting the prior probability within a small rectangle to be zero.</p> <p>Example parameter estimation scripts using <code>bilby</code> can be found in the <code>bilby_scripts/</code> directory in the Git repo. The scripts can be run with a configuration file.</p> <pre><code>python PE_full.py /path/to/config_file.json\n</code></pre> <p>Example configuration files can be found in the <code>config/</code> directory. The dictionaries required in the <code>json</code> configuration file are as follows:</p> <ul> <li> <p><code>injection_parameters</code>: the injected parameters for the lensed waveform. These include all the parameters of the unlensed waveform (passed to the waveform generator in <code>bilby</code>), in addition to the following lens parameters:</p> Name Type Description <code>y</code> <code>float</code> Injected impact parameter for the lensing set-up <code>MLz</code> <code>float</code> Injected redshifted lens mass <code>lp</code> <code>float</code> Injected lens parameter of the lens </li> <li> <p><code>waveform_arguments</code>: the keyword arguments to be passed to the <code>bilby.gw.waveform_generator.WaveformGenerator</code> object in <code>bilby</code>.</p> </li> <li><code>sampler_settings</code>: the keyword arguments to be passed to the <code>bilby.run_sampler</code> function.</li> <li><code>interpolator_settings</code>: the settings of the interpolator used, see the tutorial for loading the interpolation tables for more details.</li> <li> <p><code>prior_settings</code>: the settings for the priors of the lensing related parameters and <code>luminosity_distance</code>. For example, the prior type (<code>uniform</code>, <code>loguniform</code>) and limits of <code>MLz</code> can be specified by <code>MLz_prior_type</code>, <code>MLz_min</code> and <code>MLz_max</code>. For <code>luminosity_distance</code>, the prior can be chosen to be <code>uniformsourceframe</code>. Additional arguements for masking the region near the caustic are as follows:</p> Name Type Description <code>crit_mask_settings</code> <code>dict</code> Parameters of the masker around the caustic, including <code>fac</code>, <code>cap_high</code> and <code>cap_low</code>. The masked region is defined to be between <code>y_c - min( y_c * fac, y_c - cap_low )</code> and <code>y_c + min( y_c * fac, y_c + cap_high)</code>. <code>mask_boxes</code> <code>list</code> Each item is a list <code>[[y_low, y_high],[l_low, l_high]]</code>, the boundaries of a rectangular region to exclude in the \\(y\\)-\\(l\\) plane </li> <li> <p><code>misc</code>: miscellaneous settings as follows:</p> Name Type Description <code>zero_noise</code> <code>bool</code> Whether to perform a zero-noise injection. <code>sampling_frequency</code> <code>float</code> The sampling rate of the signal in Hertz. <code>minimum_frequency</code> <code>float</code> Minimum frequency cut-off. <code>seed</code> <code>int</code> The seed used to generate random numbers for sampling. <code>lp_name</code> <code>str</code> The name given to the lens parameter, e.g. <code>kappa</code> for the NFW lens. <code>lp_latex</code> <code>str</code> The name of the lens parameter in latex form for making plots <code>outdir_ext</code> <code>str</code> The name of the output directory </li> </ul>"},{"location":"tutorial/example_amplification_minimal/","title":"Computing the amplification factor","text":"In\u00a0[1]: Copied! <pre>from jax import jit\nimport jax.numpy as jnp\n\nfrom glworia.amp.lens_model import LensModel\nfrom glworia.amp.amplification_factor import (amplification_computation_prep, \n                                          crtical_curve_interpolants,\n                                          compute_F)\nfrom glworia.amp.root import make_crit_curve_helper_func\nimport matplotlib.pyplot as plt\n</pre> from jax import jit import jax.numpy as jnp  from glworia.amp.lens_model import LensModel from glworia.amp.amplification_factor import (amplification_computation_prep,                                            crtical_curve_interpolants,                                           compute_F) from glworia.amp.root import make_crit_curve_helper_func import matplotlib.pyplot as plt <pre>WARNING: All log messages before absl::InitializeLog() is called are written to STDERR\nI0000 00:00:1706818445.491190  827101 tfrt_cpu_pjrt_client.cc:349] TfrtCpuClient created.\nNo GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[2]: Copied! <pre>class PlummerLens(LensModel):\n\n    def __init__(self):\n        pass\n\n    def get_Psi(self):\n        @jit\n        def Psi_Plummer(x, lens_params):\n            kappa = lens_params[0]\n            return kappa / 2 * jnp.log(1 + jnp.linalg.norm(x)**2)\n        return Psi_Plummer\n</pre> class PlummerLens(LensModel):      def __init__(self):         pass      def get_Psi(self):         @jit         def Psi_Plummer(x, lens_params):             kappa = lens_params[0]             return kappa / 2 * jnp.log(1 + jnp.linalg.norm(x)**2)         return Psi_Plummer In\u00a0[3]: Copied! <pre>lm = PlummerLens()\nPsi_Plummer = lm.get_Psi()\nT_funcs, helper_funcs = amplification_computation_prep(Psi_Plummer)\ncrit_curve_helper_funcs = make_crit_curve_helper_func(T_funcs)\n</pre> lm = PlummerLens() Psi_Plummer = lm.get_Psi() T_funcs, helper_funcs = amplification_computation_prep(Psi_Plummer) crit_curve_helper_funcs = make_crit_curve_helper_func(T_funcs) In\u00a0[4]: Copied! <pre>param_arr = jnp.linspace(0.1, 10., 100000)\ncrit_funcs = crtical_curve_interpolants(param_arr, T_funcs, crit_curve_helper_funcs)\n</pre> param_arr = jnp.linspace(0.1, 10., 100000) crit_funcs = crtical_curve_interpolants(param_arr, T_funcs, crit_curve_helper_funcs) In\u00a0[5]: Copied! <pre>ws = jnp.linspace(1e-2, 1e3, 10**6)\ny = jnp.array([0.1, 0.])\nlens_params = jnp.array([5.])\n\nN = 200\nT0_max = 1000.\n\nF_interp, _, _, _ = compute_F(ws, y, lens_params, T_funcs, helper_funcs, crit_funcs,\n              N, T0_max)\n</pre> ws = jnp.linspace(1e-2, 1e3, 10**6) y = jnp.array([0.1, 0.]) lens_params = jnp.array([5.])  N = 200 T0_max = 1000.  F_interp, _, _, _ = compute_F(ws, y, lens_params, T_funcs, helper_funcs, crit_funcs,               N, T0_max) In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots()\nax.semilogx(ws, jnp.abs(F_interp))\nax.set_xlabel(r'$w$')\nax.set_ylabel(r'$|F|$')\n</pre> fig, ax = plt.subplots() ax.semilogx(ws, jnp.abs(F_interp)) ax.set_xlabel(r'$w$') ax.set_ylabel(r'$|F|$') Out[6]: <pre>Text(0, 0.5, '$|F|$')</pre>"},{"location":"tutorial/example_load_interpolation/","title":"Loading an interpolation table","text":"In\u00a0[19]: Copied! <pre>from glworia.amp.load_interp import load_interpolators, F_interp\nimport json\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from glworia.amp.load_interp import load_interpolators, F_interp import json import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>interpolation_dir_path = '../../interpolation'\n</pre> interpolation_dir_path = '../../interpolation' In\u00a0[3]: Copied! <pre>settings_file_path = '../../settings/NFW_prod1.json'\n</pre> settings_file_path = '../../settings/NFW_prod1.json' In\u00a0[4]: Copied! <pre>with open(settings_file_path, 'r') as f:\n    settings = json.load(f)\n</pre> with open(settings_file_path, 'r') as f:     settings = json.load(f) In\u00a0[6]: Copied! <pre>interpolators = load_interpolators(interpolation_dir_path, **settings)\n</pre> interpolators = load_interpolators(interpolation_dir_path, **settings) In\u00a0[30]: Copied! <pre>w_interp = np.linspace(0.001, 1e4, 10**6)\ny_interp = 0.23456\nlp_interp = 5.01234\n</pre> w_interp = np.linspace(0.001, 1e4, 10**6) y_interp = 0.23456 lp_interp = 5.01234 In\u00a0[31]: Copied! <pre>F = F_interp(w_interp, y_interp, lp_interp, interpolators, settings)\n</pre> F = F_interp(w_interp, y_interp, lp_interp, interpolators, settings) In\u00a0[33]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize = (12, 5))\naxs[0].semilogx(w_interp, np.abs(F))\naxs[1].semilogx(w_interp, np.angle(F))\n\naxs[0].set_xlabel('$w$')\naxs[0].set_ylabel('$|F|$')\naxs[1].set_xlabel('$w$')\naxs[1].set_ylabel(r'$\\arg(F)$')\n</pre> fig, axs = plt.subplots(1, 2, figsize = (12, 5)) axs[0].semilogx(w_interp, np.abs(F)) axs[1].semilogx(w_interp, np.angle(F))  axs[0].set_xlabel('$w$') axs[0].set_ylabel('$|F|$') axs[1].set_xlabel('$w$') axs[1].set_ylabel(r'$\\arg(F)$') Out[33]: <pre>Text(0, 0.5, '$\\\\arg(F)$')</pre>"},{"location":"tutorial/example_load_interpolation/#constructing-an-interpolation-table","title":"Constructing an interpolation table\u00b6","text":"<p>To construct an interpolation table, use the <code>do_interpolation.py</code> python script with a configuration file.</p> <pre><code>python scripts/do_interpolation.py -f /path/to/config_file.json -s /path/to/output/directory -im\n</code></pre> Option flag Description <code>--input-file</code> <code>-f</code> Path to configuration file. <code>--save-dir</code> <code>-s</code> Path to directory for saving the interpolation tables. <code>--image</code> <code>-im</code> Also construct an interpolation table for the image magnifications and time delays, in addition to the amplification factor. <code>--skip-strong</code> <code>-ss</code> Skip the strong lensing region in the parameter space. <code>--skip-weak</code> <code>-sw</code> Skip the weak lensing region in the parameter space. <code>--skip-amplification</code> <code>-sa</code> Skip the computation of the amplification factor. <p>The configuration file should be in <code>json</code> format with the following entries:</p> Parameter Type Description <code>lens_param_name</code> <code>str</code> Name given to the lens parameter $l$, e.g. <code>kappa</code> for the NFW lens or <code>x_c</code> for the CIS lens. <code>y_low</code> <code>float</code> Lower limit of the impact parameter $y$ in the interpolation domain. <code>y_high</code> <code>float</code> Upper limit of the impact parameter $y$ in the interpolation domain. <code>lp_low</code> <code>float</code> Lower limit of the lens parameter $l$ in the interpolation domain. <code>lp_high</code> <code>float</code> Upper limit of the lens parameter $l$ in the interpolation domain. <code>N_grid</code> <code>int</code> Number of interpolation nodes to use in each dimension on the $y$-$l$ plane to use for the weak lensing region. <code>N_grid_strong</code> <code>int</code> Number of interpolation nodes to use in each dimension on the $y$-$l$ plane to use for the strong lensing region. <code>N_crit</code> <code>int</code> Number of interpolation nodes on the caustic curve. <code>N</code> <code>int</code> Number of interpolation nodes in dimensionless time $\\tau$ to use in each section of the time domain amplification factor. <code>lens_model_name</code> <code>str</code> The name of the lens model, e.g. <code>NFW</code>. <code>crit_lp_N</code> <code>int</code> Number of points in $l$ to use for a high-resolution interpolator tracing out the caustic curve in the $y$-$l$ plane. <code>im_x_init_low</code> <code>float</code> Lower limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_high</code> <code>float</code> Upper limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_num</code> <code>int</code> Number of points in the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>lp_low_im</code> <code>float</code> Lower limit of the lens parameter $l$ in the interpolation domain for image related quantities. <code>lp_high_im</code> <code>float</code> Upper limit of the lens parameter $l$ in the interpolation domain for image related quantities. <code>N_grid_im</code> <code>int</code> Number of interpolation nodes to use in each dimension on the $y$-$l$ plane to use for interpolating image related quantities. <code>N_crit_im</code> <code>int</code> Number of interpolation nodes to use on the caustic curve for interpolating image related quantities. <code>newt_max_iter_im</code> <code>int</code> Maximum iterations for Newton's method when solving for the image positions. <code>crit_lp_im</code> <code>int</code> Number of points in $l$ to use for a high-resolution interpolator tracing out the caustic curve in the $y$-$l$ plane, for calculations related to the images."},{"location":"tutorial/interpolation_tutorial/","title":"Constructing an interpolation table","text":"<p>To construct an interpolation table, use the <code>do_interpolation.py</code> python script with a configuration file.</p> <pre><code>python scripts/do_interpolation.py -f /path/to/config_file.json -s /path/to/output/directory -im\n</code></pre> Option flag Description <code>--input-file</code> <code>-f</code> Path to configuration file. <code>--save-dir</code> <code>-s</code> Path to directory for saving the interpolation tables. <code>--image</code> <code>-im</code> Also construct an interpolation table for the image magnifications and time delays, in addition to the amplification factor. <code>--skip-strong</code> <code>-ss</code> Skip the strong lensing region in the parameter space. <code>--skip-weak</code> <code>-sw</code> Skip the weak lensing region in the parameter space. <code>--skip-amplification</code> <code>-sa</code> Skip the computation of the amplification factor. <p>The configuration file should be in <code>json</code> format with the following entries:</p> Parameter Type Description <code>lens_param_name</code> <code>str</code> Name given to the lens parameter \\(l\\), e.g. <code>kappa</code> for the NFW lens or <code>x_c</code> for the CIS lens. <code>y_low</code> <code>float</code> Lower limit of the impact parameter \\(y\\) in the interpolation domain. <code>y_high</code> <code>float</code> Upper limit of the impact parameter \\(y\\) in the interpolation domain. <code>lp_low</code> <code>float</code> Lower limit of the lens parameter \\(l\\) in the interpolation domain. <code>lp_high</code> <code>float</code> Upper limit of the lens parameter \\(l\\) in the interpolation domain. <code>N_grid</code> <code>int</code> Number of interpolation nodes to use in each dimension on the \\(y\\)-\\(l\\) plane to use for the weak lensing region. <code>N_grid_strong</code> <code>int</code> Number of interpolation nodes to use in each dimension on the \\(y\\)-\\(l\\) plane to use for the strong lensing region. <code>N_crit</code> <code>int</code> Number of interpolation nodes on the caustic curve. <code>N</code> <code>int</code> Number of interpolation nodes in dimensionless time \\(\\tau\\) to use in each section of the time domain amplification factor. <code>lens_model_name</code> <code>str</code> The name of the lens model, e.g. <code>NFW</code>. <code>crit_lp_N</code> <code>int</code> Number of points in \\(l\\) to use for a high-resolution interpolator tracing out the caustic curve in the \\(y\\)-\\(l\\) plane. <code>im_x_init_low</code> <code>float</code> Lower limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_high</code> <code>float</code> Upper limit of the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>im_x_init_num</code> <code>int</code> Number of points in the <code>im_x_init</code> array of initial guesses for Newton's method when solving for image positions. <code>lp_low_im</code> <code>float</code> Lower limit of the lens parameter \\(l\\) in the interpolation domain for image related quantities. <code>lp_high_im</code> <code>float</code> Upper limit of the lens parameter \\(l\\) in the interpolation domain for image related quantities. <code>N_grid_im</code> <code>int</code> Number of interpolation nodes to use in each dimension on the \\(y\\)-\\(l\\) plane to use for interpolating image related quantities. <code>N_crit_im</code> <code>int</code> Number of interpolation nodes to use on the caustic curve for interpolating image related quantities. <code>newt_max_iter_im</code> <code>int</code> Maximum iterations for Newton's method when solving for the image positions. <code>crit_lp_im</code> <code>int</code> Number of points in \\(l\\) to use for a high-resolution interpolator tracing out the caustic curve in the \\(y\\)-\\(l\\) plane, for calculations related to the images."}]}