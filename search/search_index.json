{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/amp/amplification_factor/","title":"API for the <code>glworia.am.amplification_factor</code> module","text":""},{"location":"api/amp/amplification_factor/#glworia.amp.amplification_factor.amplification_computation_prep","title":"<code>amplification_computation_prep(Psi, **kwargs)</code>","text":"<p>Constructs the functions needed for computing the amplification factor.</p> <p>Parameters:</p> Name Type Description Default <code>Psi</code> <code>Callable</code> <p>The Fermat potential of the lens model.</p> required <p>Other Parameters:</p> Name Type Description <code>h</code> <code>float</code> <p>The step size for numerical differentiation.</p> <code>newt_tol</code> <code>float</code> <p>The tolerance for the Newton's method.</p> <code>newt_max_iter</code> <code>int</code> <p>The maximum number of iterations for the Newton's method.</p> <code>bisect_tol</code> <code>float</code> <p>The tolerance for the bisection method.</p> <p>Returns:</p> Name Type Description <code>T_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of functions needed for computing the amplification factor.</p> <code>helper_funcs</code> <code>Dict[str, Callable]</code> <p>A dictionary of helper functions needed for computing the amplification factor.</p>"},{"location":"examples/example_amplification_minimal/","title":"Computing the amplification factor","text":"In\u00a0[1]: Copied! <pre>from jax import jit\nimport jax.numpy as jnp\n\nfrom glworia.amp.lens_model import LensModel\nfrom glworia.amp.amplification_factor import (amplification_computation_prep, \n                                          crtical_curve_interpolants,\n                                          compute_F)\nfrom glworia.amp.root import make_crit_curve_helper_func\nimport matplotlib.pyplot as plt\n</pre> from jax import jit import jax.numpy as jnp  from glworia.amp.lens_model import LensModel from glworia.amp.amplification_factor import (amplification_computation_prep,                                            crtical_curve_interpolants,                                           compute_F) from glworia.amp.root import make_crit_curve_helper_func import matplotlib.pyplot as plt <pre>WARNING: All log messages before absl::InitializeLog() is called are written to STDERR\nI0000 00:00:1706818445.491190  827101 tfrt_cpu_pjrt_client.cc:349] TfrtCpuClient created.\nNo GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[2]: Copied! <pre>class PlummerLens(LensModel):\n\n    def __init__(self):\n        pass\n\n    def get_Psi(self):\n        @jit\n        def Psi_Plummer(x, lens_params):\n            kappa = lens_params[0]\n            return kappa / 2 * jnp.log(1 + jnp.linalg.norm(x)**2)\n        return Psi_Plummer\n</pre> class PlummerLens(LensModel):      def __init__(self):         pass      def get_Psi(self):         @jit         def Psi_Plummer(x, lens_params):             kappa = lens_params[0]             return kappa / 2 * jnp.log(1 + jnp.linalg.norm(x)**2)         return Psi_Plummer In\u00a0[3]: Copied! <pre>lm = PlummerLens()\nPsi_Plummer = lm.get_Psi()\nT_funcs, helper_funcs = amplification_computation_prep(Psi_Plummer)\ncrit_curve_helper_funcs = make_crit_curve_helper_func(T_funcs)\n</pre> lm = PlummerLens() Psi_Plummer = lm.get_Psi() T_funcs, helper_funcs = amplification_computation_prep(Psi_Plummer) crit_curve_helper_funcs = make_crit_curve_helper_func(T_funcs) In\u00a0[4]: Copied! <pre>param_arr = jnp.linspace(0.1, 10., 100000)\ncrit_funcs = crtical_curve_interpolants(param_arr, T_funcs, crit_curve_helper_funcs)\n</pre> param_arr = jnp.linspace(0.1, 10., 100000) crit_funcs = crtical_curve_interpolants(param_arr, T_funcs, crit_curve_helper_funcs) In\u00a0[5]: Copied! <pre>ws = jnp.linspace(1e-2, 1e3, 10**6)\ny = jnp.array([0.1, 0.])\nlens_params = jnp.array([5.])\n\nN = 200\nT0_max = 1000.\n\nF_interp, _, _, _ = compute_F(ws, y, lens_params, T_funcs, helper_funcs, crit_funcs,\n              N, T0_max)\n</pre> ws = jnp.linspace(1e-2, 1e3, 10**6) y = jnp.array([0.1, 0.]) lens_params = jnp.array([5.])  N = 200 T0_max = 1000.  F_interp, _, _, _ = compute_F(ws, y, lens_params, T_funcs, helper_funcs, crit_funcs,               N, T0_max) In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots()\nax.semilogx(ws, jnp.abs(F_interp))\nax.set_xlabel(r'$w$')\nax.set_ylabel(r'$|F|$')\n</pre> fig, ax = plt.subplots() ax.semilogx(ws, jnp.abs(F_interp)) ax.set_xlabel(r'$w$') ax.set_ylabel(r'$|F|$') Out[6]: <pre>Text(0, 0.5, '$|F|$')</pre>"}]}